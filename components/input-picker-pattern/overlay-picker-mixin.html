<link rel="import" href="overlay-element.html">
<link rel="import" href="input-shared-style.html">
<link rel="import" href="dropdown-tip-style.html">

<script>
  /**
   * mixin to extend an picker with an `overlay-element`
   *
   * @mixinFunction
   * @polymer
   */
  const OverlayPickerMixin = superClass => { // eslint-disable-line no-unused-vars

    return class extends superClass {

      static get properties() {
        return {
          /**
           * Set to true to keep overlay always on top.
           */
          alwaysOnTop: {
            type: Boolean
          },
          /**
           * Will position the element around the positionTarget without overlapping it.
           */
          noOverlap: {
            type: Boolean,
            value: false
          },
          /**
           * Set to true to display a backdrop behind the overlay. It traps the focus
           * within the light DOM of the overlay.
           */
          withBackdrop: {
            type: Boolean,
            value: false
          },
          /**
           * Set to true to disable canceling the overlay by clicking outside it.
           */
          noCancelOnOutsideClick: {
            type: Boolean,
            value: false
          },

          /**
           * If true, it will use `horizontalAlign` and `verticalAlign` values as preferred alignment
           * and if there's not enough space, it will pick the values which minimize the cropping.
           */
          dynamicAlign: {
            type: Boolean,
            reflectToAttribute: true
          },

          /**
           * Set to true to auto-fit on attach.
           */
          autoFitOnAttach: {
            type: Boolean,
            value: false
          },

          /**
           * The element to fit the overlay into. By default it is the window.
           */
          fitInto: {
            type: Object
          },

          /**
           * The element that should be used to position the overlay. If not set, it will
           * default to the polyfill node.
           */
          positionTarget: {
            type: Element
          },

          _sizingTarget: {
            type: Element,
            readOnly: true
          }
        }
      }

      static get pickerTemplate() {
        return `
          <overlay-element id="overlay"
            always-on-top="[[alwaysOnTop]]"
            with-backdrop="[[withBackdrop]]"
            no-cancel-on-outside-click="[[noCancelOnOutsideClick]]"
            no-cancel-on-esc-key="[[noCancelOnEscKey]]"
            no-overlap="[[noOverlap]]"
            auto-fit-on-attach="[[autoFitOnAttach]]"
            dynamic-align="[[dynamicAlign]]"
            vertical-align="[[verticalAlign]]"
            horizontal-align="[[horizontalAlign]]"
            position-target="[[positionTarget]]"
            sizing-target="[[_sizingTarget]]"
            fit-into="[[fitInto]]"
            opened="{{opened}}">
            ${super.pickerTemplate}
          </overlay-element>
        `;
      }

      static get customStyleContent() {
        return `
          ${super.customStyleContent || ''}
          #overlay {
            display: -webkit-inline-flex;
            display: -ms-inline-flexbox;
            display: inline-flex;
            flex-shrink: 0;
            padding: 0;
          }
        `;
      }

      static get customStyleToInclude() {
        return 'input-shared-style dropdown-tip-style';
      }

      connectedCallback() {
        super.connectedCallback();
        this.positionTarget = this;
        this._set_sizingTarget(this.$.overlay);
        this.fit();
        this._initializeInputs = this._initializeInputs.bind(this);
        this.addEventListener('iron-overlay-opened', this._initializeInputs, true);
        this.addEventListener('iron-resize', this._initializeInputs, true);
      }

      /**
       * Positions and fits the overlay into the `fitInto` element.
       */
      fit() {
        this.$.overlay.fit();
      }

      open() {
        super.open();
        this.fit();
      }

      _initializeInputs() {
        // neccessary because the overlay is hidden initially and the inputs are sized dynamically and so a width has still to be computed for the inputs
        const inputs = this.root.querySelectorAll('integer-input, number-input, text-input');
        if (inputs) {
          Array.prototype.forEach.call(inputs, inp => {
            inp.resize && inp.resize();
          });
          this.removeEventListener('iron-overlay-opened', this._initializeInputs, true);
        }
      }

      /**
       * notify manually the overlay to resize
       */
      notifyResize() {
        this.$.overlay.notifyResize();
      }
    }
  }

  window.OverlayPickerMixin = OverlayPickerMixin;
</script>
