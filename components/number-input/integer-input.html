<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../property-mixins/range-mixin.html">
<link rel="import" href="../input-picker-pattern/form-element-mixin.html">

<script>
  /**
   * mixin to create a integer-input
   *
   * @appliesMixin RangeMixin
   * @appliesMixin FormElementMixin
   *
   * @mixinFunction
   * @polymer
   */
  const IntegerInputMixin = (superClass) => { // eslint-disable-line no-unused-vars

    return class extends RangeMixin(FormElementMixin(superClass)) {

      constructor() {
        super();
        /**
         * IE & Edge ch-unit fix
         */
        this._chCorrection = window.navigator.userAgent.match(/Edge|Trident/g) ? 1.25 : 1;
      }

      static get template() {
        return `
          ${this.styleTemplate}
          ${this.contentTemplate}
        `;
      }

      static get styleTemplate() {
        return `
          <style>
            :host {
              display: inline-flex;
              box-sizing: content-box;
              padding: 0 !important;
            }
            :host([invalid]) #input,
            #input:invalid {
              @apply --input-invalid;
              @apply --number-input-invalid;
            }
            #input {
              font-family: inherit;
              font-size: inherit;
              font-weight: inherit;
              text-align: var(--number-input-allign, center);
              overflow: visible;
              box-sizing: content-box;
              border: 0;
              border-color: transparent;
              color: var(--number-input-color, var(--input-color, inherit));
              background: var(--number-input-background, var(--input-background, transparent));
              @apply --input-style;
              @apply --number-input;
            }
            #input::-webkit-input-placeholder,
            #input::placeholder {
              @apply --number-input-placeholder;
            }
            #input:hover,
            #input:focus {
              outline: none;
              color: var(--number-input-focus-color, var(--input-focus-color, inherit));
              background: var(--number-input-focus-background, var(--input-focus-background, rgba(0,0,0,0.1)));
              @apply --input-focus;
              @apply --number-input-focus;
            }
            :host([disabled]) {
              color: var(--number-input-disabled-color, var(--input-disabled-color, inherit));
              background: var(--number-input-disabled-background, var(--input-disabled-background, inherit));
              @apply --input-disabled;
            }
          </style>
        `;
      }

      static get contentTemplate() {
        return `
          <input id="input"
            type="tel"
            placeholder="[[placeholder]]"
            required="[[required]]"
            disabled="[[disabled]]"
            on-focus="_updateView"
            on-blur="_updateView"
            on-keydown="_checkKeycode"
            on-keyup="_stopIncrem">
        `;
      }

      static get properties() {
        return {
          /**
           * length to pad the string (with `0`) according to the total amount of numbers
           * @type {number}
           */
          padLength: {
            type: Number,
            observer: '_updateView'
          },

          /**
           * placeholder string
           * @type {string}
           */
          placeholder: {
            type: String,
            observer: '_computeMinWidth'
          },

          /**
           * disable autosizing
           * @type {boolean}
           */
          noAutoWidth: {
            type: Boolean,
            value: false,
            observer: '_noAutoWidthChanged'
          },

          /**
           * enables auto padding
           * @type {boolean}
           */
          autoPadding: {
            type: Boolean,
            observer: '_updateView'
          },

          /**
           * string value of the input
           * @type {string}
           */
          input: {
            type: String,
            notify: true,
            observer: '_inputChanged'
          },

          /**
           * always put the sign in the beginning
           * @type {string}
           */
          alwaysSign: {
            type: Boolean,
            observer: '_updateView'
          },

          step: {
            type: Number,
            value: 1,
            observer: '_stepChanged'
          },

          /**
           * minimum digits left to the decimal separator to pad
           * @type {number}
           */
          minimumIntegerDigits: {
            type: Number,
            // polymorphism bug in polymer
            computed: '_computeMinimumIntegerDigits(autoPadding, padLength, min, max, step, inPercent)'
          },

          /**
           * longest number-string of the given range
           * @type {number}
           */
          _longestStaticLength: {
            type: Number,
            computed: '_computeLongestStatic(alwaysSign, minimumIntegerDigits, minimumFractionDigits)',
            observer: '_updateView'
          },

          _regExpNotInNumber: {
            type: RegExp,
            value: /[^\d\-\+\.]/g
          },

          _regExpSeparators: {
            type: RegExp,
            value: /[^\-\+\.]/g
          }
        }
      }

      static get observers() {
        return [
          '_debouncedComputeWidth(input)'
        ]
      }

      connectedCallback() {
        super.connectedCallback();
        this._ensureAttribute('tabindex', 0);
        this.addEventListener('focus', this.focus.bind(this), false);
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener('focus', this.focus.bind(this), false);
      }

      _computeMinimumIntegerDigits(autoPadding, padLength, min, max) {
        min = '' + (min || '');
        max = '' + (max || '');
        if (autoPadding) {
          return Math.max((padLength || 0), min.length, max.length);
        }
        if (padLength) {
          return Math.max(1, (padLength || 0));
        }
        return 1;
      }

      _computeLongestStatic(alwaysSign, minimumIntegerDigits) {
        return this._computeChWidth((!alwaysSign && (this.min < 0 || this.max < 0) ? '-' : '') + this.formatNumber(Math.pow(10, minimumIntegerDigits - 1)));
      }

      // approximation of the ch-width of a number-string
      _computeChWidth(str) {
        if (str === undefined) {
          return 0;
        }
        return str.replace(/\D/g, '').length + str.replace(/[^+\\\/\?~_]/g, '').length + str.replace(/[^.,;\-*!(){}®«»±[\]'"´‹›`²³°\u2070-\u209C]/g, '').length/2;
      }

      // approximation of the width of a string
      _computeEmWidth(str) {
        if (str === undefined) {
          return 0;
        }
        return str.replace(/[\d\s+\\\/\?~_^.,;\-*!(){}®«»±[\]'"´‹›`²³°\u2070-\u209C]/g,'').length + str.replace(/[^%#&$€£¥§©]/g,'')*0.75 + str.replace(/\S/g, '').length/4;
      }

      _computeMinWidth(placeholder) {
        placeholder = '' + (placeholder || '');
        this.$.input.style.minWidth = `calc(${this._computeEmWidth(placeholder)}em + ${this._computeChWidth(placeholder)}ch)`;
      }

      _computeInvalid(required, value) {
        return required && isNaN(value);
      }

      _inputChanged(input, oldinput) {
        if (!input) {
          if (oldinput) {
            this._inputChanged(oldinput);
          }
          return;
        }
        input = input.replace(this._regExpNotInNumber, '');
        oldinput = (oldinput || '').replace(this._regExpNotInNumber, '');

        const newValue = parseInt(input);
        const oldValue = parseInt(oldinput);
        let value;

        if (isNaN(oldValue)) {
          if (isNaN(this.default)) {
            value = this._checkValue(newValue);
          } else {
            value = this._checkValue(newValue, this.default);
          }
        } else {
          value = this._checkValue(newValue, oldValue);
        }
        input = this.formatNumber(value);

        if (this.input !== input) {
          this.input = input;
          return;
        }

        this.$.input.value = input;
        this.value = value;
      }

      _valueChanged(value, oldValue) {
        if (value === undefined) return;

        if (isNaN(oldValue)) {
          value = this._checkValue(value);
        } else {
          value = this._checkValue(value, oldValue);
        }

        if (this.value !== value) {
          this.value = value;
          return;
        }
        this.input = this.$.input.value = this.formatNumber(value);
      }

      _checkKeycode(e) {
        if (!e.target) {
          if (e && e.preventDefault) e.preventDefault();
          return;
        }
        // up or down key press
        const inc = (e.keyCode === 38) ? this.step : (e.keyCode === 40 ? -this.step : 0);
        if (inc !== 0) {
          this._startIncrem(inc);
          e.preventDefault();
          e.stopPropagation();
          return;
        }

        // enter & space
        if (e.keyCode === 13 || e.keyCode === 32) {
          this._updateView();
          return;
        }

        // esc
        if (e.keyCode === 27) {
          this._updateView();
          this.blur();
          return;
        }
      }

      _startIncrem(step) {
        this._stopIncrem();
        this._increm(step);
        this._activeIncremJob = setInterval(() => {
          this._increm(step);
        }, 150);
      }

      _stopIncrem() {
        if (this._activeIncremJob) {
          clearInterval(this._activeIncremJob);
        }
      }

      _increm(step) {
        const value = parseInt(this.$.input.value.replace(this._regExpNotInNumber, '')) + step;
        this.value = this._checkValue(value, this.value);
      }

      _updateView() {
        this._inputChanged(this.$.input.value, this.input);
        this._debouncedComputeWidth(this.input);
      }

      _debouncedComputeWidth(input) {
        if (this._activeResizeJob) {
          cancelAnimationFrame(this._activeResizeJob);
        }
        this._activeResizeJob = requestAnimationFrame(this._computeWidth.bind(this, input));
      }

      _computeWidth(input) {
        if (this.noAutoWidth) return;

        input = input || '';

        const currLength = this._computeChWidth(input);
        const length = Math.max(this._longestStaticLength, currLength) * this._chCorrection;

        this.$.input.style.width = `${length}ch`;
      }

      _noAutoWidthChanged(noAutoWidth) {
        if (!noAutoWidth) {
          this._debouncedComputeWidth(this.input);
          return;
        }
        this.$.input.style.width = '';
      }

      /**
       * focus the input
       */
      focus() {
        this.$.input.focus();
      }

      /**
       * focus the input
       */
      blur() {
        this.$.input.blur();
      }

      formatNumber() {
        const n = arguments[0];
        let str = '' + Math.abs(n);
        while (str.length < this.minimumIntegerDigits) {
          str = '0' + str;
        }
        if (n < 0) {
          str = '-' + str;
        } else if (this.alwaysSign) {
          str = '+' + str;
        }
        return str;
      }
    }
  }
</script>

<dom-module id="integer-input">
  <script>
    /**
     *  `integer-input` is an element that can:
     * * prevent non numeric input
     * * guarantee **live**-data to be valid
     * * pad a value with `0` (to a specific length)
     * * size the input (according to it's length)
     * * overflow to minimum or underflow to maximum
     * * saturate to minimum or to maximum
     * * display a specified unit and size the input
     *
     * Example:
     * ```html
     * <integer-input step="2" min="-20" max="140" pad-length="2"></integer-input>
     * ```
     *
     * It sizes automatically. Use `key-up` and `key-down` to increment the value. If `step` is given, the value is a **multiple** of `step`.
     *
     * ### Styling
     * Custom property                   | Description                                  | Default
     * ----------------------------------|----------------------------------------------|--------------------
     * `--number-input`                  | style of the input                           | {}
     * `--number-input-focus`            | style of the focussed and hovered input      | {}
     * `--number-input-placeholder`      | style of the placeholder                     | {}
     * `--number-input-color`            | color of the input                           | inherit
     * `--number-input-background`       | background of the input                      | inherit
     * `--number-input-focus-color`      | color of the focussed and hovered input      | inherit
     * `--number-input-focus-background` | background of the focussed and hovered input | rgba(0,0,0,0.1)
     * `--number-input-disabled-color`   | color of the disabled input                  | inherit
     *
     * ```css
     * :host {
     *   --number-input-disabled-color: grey;
     *   --number-input-focus-background: rgba(0,0,0,0.25);
     *   --number-input-focus: {
     *     font-weight: bold;
     *   };
     *   --number-input-placeholder: {
     *     color: pink;
     *   };
     * }
     * ```
     * @polymer
     * @customElement
     *
     * @appliesMixin IntegerInputMixin
     *
     * @demo demo/index.html
     * @demo demo/form.html Form Demo
     **/
    class IntegerInput extends IntegerInputMixin(Polymer.Element) {

      static get is() {
        return 'integer-input';
      }
    }
    window.customElements.define(IntegerInput.is, IntegerInput);
  </script>
</dom-module>
