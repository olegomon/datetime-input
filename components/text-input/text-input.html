<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../input-picker-pattern/form-element-mixin.html">

<script>
  /**
   * mixin to create a text-input
   *
   * @appliesMixin FormElementMixin
   *
   * @mixinFunction
   * @polymer
   */
  const TextInputMixin = (superClass) => { // eslint-disable-line no-unused-vars

    return class extends FormElementMixin(superClass) { // eslint-disable-line no-undef

      static get template() {
        return `
          ${this.styleTemplate}
          ${this.contentTemplate}
        `;
      }

      static get styleTemplate() {
        return `
          <style>
            :host {
              display: inline-flex;
              box-sizing: content-box;
              padding: 0 !important;
            }
            :host(:focus),
            #input:focus {
              outline: none;
            }
            #input {
              font-family: inherit;
              font-size: inherit;
              font-weight: inherit;
              text-align: var(--text-input-allign, center);
              overflow: visible;
              box-sizing: content-box;
              border: none;
              outline: none;
              -webkit-background-clip: padding-box;
              background-clip: padding-box;
              border-color: transparent;
              line-height: 1;
              color: var(--text-input-color, var(--input-color, inherit));
              background: var(--text-input-background, var(--input-background, inherit));
              @apply --input-style;
              @apply --text-input;
            }
            #input::-webkit-input-placeholder,
            #input::placeholder {
              @apply --input-placeholder;
              @apply --text-input-placeholder;
            }
            #input:hover,
            #input:focus {
              color: var(--text-input-focus-color, var(--input-focus-color, var(--text-input-color, inherit)));
              background: var(--text-input-focus-background, var(--input-focus-background, var(--text-input-background, inherit)));
              @apply --input-focus;
              @apply --text-input-focus;
            }
            input::-moz-focus-inner {
              border-style: none;
              padding: 0;
            }
            input::-moz-focusring {
              border-width: 0;
              color: transparent;
              text-shadow: 0 0 0 var(--text-input-focus-color, var(--input-focus-color, #000));
            }
            :host([invalid]) #input,
            #input:not(:valid),
            #input:invalid {
              @apply --input-invalid;
              @apply --text-input-invalid;
            }
            :host([disabled]) {
              color: var(--text-input-disabled-color, var(--input-disabled-color, inherit));
              @apply --input-disabled;
            }
            input::-moz-selection {
              color: var(--text-input-color, var(--input-color, inherit));
              background: var(--text-input-background, var(--input-background, transparent));
            }
            input:focus::-moz-selection {
              color: var(--input-selection-color, inherit);
              background: var(--input-selection-background, rgba(255,255,255,0.5));
            }
            input::selection {
              color: var(--text-input-color, var(--input-color, inherit));
              background: var(--text-input-background, var(--input-background, transparent));
            }
            input:focus::selection {
              color: var(--input-selection-color, inherit);
              background: var(--input-selection-background, rgba(255,255,255,0.5));
            }
          </style>
        `;
      }

      static get contentTemplate() {
        return `
          <input id="input"
            type="[[type]]"
            value="{{input::input}}"
            placeholder="[[placeholder]]"
            pattern="[[pattern]]"
            disabled="[[disabled]]"
            autocomplete="[[autocomplete]]"
            required="[[required]]"
            minlength="[[minlength]]"
            maxlength="[[maxlength]]"
            size="[[size]]"
            spellcheck$="[[_computeSpellcheckAttribute(spellcheck)]]"
            on-focusin="validate"
            on-focusout="validate"
            on-blur="validate"
            on-keydown="_checkKeycode">
        `;
      }

      static get properties() {
        return {
          /**
           * autocomplete the input
           * @type {string}
           */
          autocomplete: {
            type: Boolean
          },
          /**
           * specify the type like 'password'
           * @type {string}
           */
          type: {
            type: String,
            notify: true,
            value: 'text'
          },

          /**
           * placeholder string
           * @type {string}
           */
          placeholder: {
            type: String
          },

          /**
           * regular expression pattern of the input
           * @type {string}
           */
          pattern: {
            type: String,
            notify: true,
            observer: '_patternChanged'
          },

          /**
           * default value of the input
           * @type {string}
           */
          default: {
            type: String,
            notify: true,
            observer: '_inputChanged'
          },

          /**
           * value string of the input
           * @type {string}
           */
          input: {
            type: String,
            notify: true,
            observer: '_inputChanged'
          },

          /**
           * value string of the input
           * @type {string}
           */
          value: {
            type: String,
            notify: true,
            value: '',
            observer: '_valueChanged'
          },

          /**
           * minlength of the input
           * @type {number}
           */
          minlength: {
            type: Number
          },

          /**
           * maxlength of the input
           * @type {number}
           */
          maxlength: {
            type: Number
          },

          /**
           * size of the input
           * @type {number}
           */
          size: {
            type: Number
          },

          /**
           * if true, the length of the value is not used for computing the size-attribute
           * @type {number}
           */
          noAutoWidth: {
            type: Boolean
          },

          /**
           * if true, the input will check the spelling
           * @type {number}
           */
          spellcheck: {
            type: Boolean,
            value: false
          }
        }
      }

      connectedCallback() {
        super.connectedCallback();
        this._ensureAttribute('tabindex', 0);
        this.addEventListener('focus', this.focus.bind(this), false);
        if (!this.noAutoWidth) {
          this._computeWidth(this.value || this.placeholder || '0');
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this.removeEventListener('focus', this.focus.bind(this), false);
      }

      validate() {
        if (this.disabled) {
          return false;
        }
        if (!(this._validationRegExp && this._validationRegExp.exec(this.$.input.value) === null) && !(this.required && !this.$.input.value)) {
          this.input = this.value = this.$.input.value;
          return true;
        } else if (!(this._validationRegExp && this._validationRegExp.exec(this.value) === null) && !(this.required && !this.value)) {
          this.input = this.$.input.value = this.value;
          return true;
        }
        return false;
      }

      _patternChanged(pattern) {
        if (!pattern) {
          this._validationRegExp = null;
          return;
        }
        this._validationRegExp = new RegExp(pattern);
        this.validate();
      }

      _inputChanged(input) {
        if (input === undefined) return;

        if (!(this._validationRegExp && this._validationRegExp.exec(input) === null)) {
          this.value = input;
        }
      }

      _valueChanged(value, oldValue) {
        if (value === undefined) return;

        if (!(this._validationRegExp && this._validationRegExp.exec(value) === null)) {
          if (!this.noAutoWidth) {
            this._computeWidth(value);
          }
          this.input = value;
        } else if (oldValue !== undefined && this._validationRegExp.exec(oldValue) !== null) {
          this.value = oldValue;
        }
      }
      _computeWidth(str) {
        this.size = str.length || 1;
      }

      _checkKeycode(e) {
        if (!e.target) {
          if (e && e.preventDefault) e.preventDefault();
          return;
        }

        // enter & space
        if (e.keyCode === 13 || e.keyCode === 32) {
          this.validate();
          return;
        }

        // esc
        if (e.keyCode === 27) {
          this.validate();
          this.blur();
          return;
        }
      }

      _computeSpellcheckAttribute(spellcheck) {
        return !spellcheck ? 'false' : 'true';
      }

      /**
       * focus the input
       */
      focus() {
        this.$.input.focus();
      }

      /**
       * focus the input
       */
      blur() {
        this.$.input.blur();
      }
    }
  }
</script>

<dom-module id="text-input">
  <script>
    /**
     *  `text-input` is an element that can:
     * * guarantee **live**-data to be valid
     * * be styled easily and in unified way
     *
     * Example:
     * ```html
     * <text-input step="2" min="-20" max="140" pad-length="2"></text-input>
     * ```
     *
     * It sizes automatically. Use `key-up` and `key-down` to increment the value. If `step` is given, the value is a **multiple** of `step`.
     *
     * ### Styling
     * Custom property                   | Description                                  | Default
     * ----------------------------------|----------------------------------------------|--------------------
     * `--text-input` | mixin applied to of the input | {}
     * `--text-input-invalid` | mixin applied to an invalid input | {}
     * `--text-input-focus` | mixin applied to the focussed and hovered input | {}
     * `--text-input-placeholder` | mixin applied to the placeholder           | {}
     * `--text-input-color` | color of the input | var(--input-color, inherit)
     * `--text-input-background` | background of the input | var(--input-background, inherit)
     * `--text-input-focus-color` | color of the focussed and hovered input | var(--input-focus-color, inherit)
     * `--text-input-focus-background` | background of the focussed and hovered input | var(--input-background-color, inherit)
     * `--text-input-disabled-color` | color of the disabled input | var(--input-disabled-color, inherit)
     * `--text-input-allign` | allignment of the text of the input | center
     * `--input-disabled` | mixin applied to the disabled input | {}
     * `--input-selection-color` | color of selected text in the input only when focused | rgba(255,255,255,0.5)
     * `--input-selection-background` | background of selected text in the input only when focused | transparent
     *
     * ```css
     * :host {
     *   --text-input-disabled-color: grey;
     *   --text-input-focus-background: rgba(0,0,0,0.25);
     *   --text-input-focus: {
     *     font-weight: bold;
     *   };
     *   --text-input-placeholder: {
     *     color: pink;
     *   };
     * }
     * ```
     * @polymer
     * @customElement
     *
     * @appliesMixin TextInputMixin
     *
     * @demo demo/index.html
     * @demo demo/iron-form.html in a form
     **/
    class TextInput extends TextInputMixin(Polymer.Element) { // eslint-disable-line no-undef

      static get is() {
        return 'text-input';
      }
    }
    window.customElements.define(TextInput.is, TextInput);
  </script>
</dom-module>
