<script>
  /**
   * mixin to provide a range behavior for a given value
   *
   * @mixinFunction
   * @polymer
   */
  const RangeMixin = (superClass) => { // eslint-disable-line no-unused-vars

    return class extends superClass {

      static get properties() {
        return {
          /**
           * minimal input
           * @type {number}
           */
          min: {
            type: Number
          },
          /**
           * maximal input
           * @type {number}
           */
          max: {
            type: Number
          },
          /**
           * step for changing the input (referencing to `min` or `0`)
           * @type {number}
           */
          step: {
            type: Number,
            value: 1,
            observer: '_stepChanged'
          },
          /**
           * value of the input
           * @type {number}
           */
          value: {
            type: Number,
            notify: true,
            observer: '_valueChanged'
          },
          /**
           * default-value of the input
           * @type {number}
           */
          default: {
            type: Number
          },
          /**
           * if true, the value does not revolve the range according to the maximum or the minimum
           * @type {boolean}
           */
          saturate: {
            type: Boolean,
            observer: '_updateValue'
          },
          /**
           * if true, the value does not clamp according to the given step
           * @type {boolean}
           */
          noClamp: {
            type: Boolean,
            observer: '_updateValue'
          },

          _isInteger: {
            type: Boolean,
            computed: '_computeIsInteger(step)'
          }
        }
      }

      static get observers() {
        return [
          '_minMaxChanged(min, max)'
        ]
      }

      connectedCallback() {
        super.connectedCallback();
        if (this.value === undefined && !isNaN(this.default)) {
          this.value = this.default;
        }
      }

      _minMaxChanged(min, max) {
        if (+max < +min) {
          this.setProperties({
            min: +max,
            max: +min
          })
        } else {
          this._updateValue();
        }
      }

      _valueChanged(value, oldValue) {
        if (value === undefined) return;

        value = this._checkValue(value, oldValue);

        if (value !== this.value) {
          this.value = value;
          return;
        }
      }

      _checkValue(value, oldValue) {
        if (isNaN(value)) {
          if (!isNaN(oldValue)) {
            return oldValue;
          } else if (!isNaN(this.default)) {
            return this.default;
          } else if (!isNaN(this.min)) {
            return this.min;
          } else if (!isNaN(this.max)) {
            return this.max;
          }
          return 0;
        }

        const saturate = this.saturate,
          min = this.min,
          max = this.max;

        if (min !== undefined && value <= min) {
          if (saturate || value === min || max === undefined || oldValue !== min) {
            return min;
          }
          return max;
        } else if (max !== undefined && value >= max) {
          if (saturate || value === max || min === undefined || max !== oldValue) {
            return max;
          }
          return min;
        } else if (this.noClamp) {
          return value;
        }
        return this._checkStep(value, this.step);
      }

      _updateValue() {
        if (this.value !== undefined) {
          this._valueChanged(this.value, this.value);
        }
      }

      _checkStep(value, step) {
        if (!step) {
          return value;
        }
        if (this.default !== undefined) {
          if (this._isInteger) {
            return Math.round((value - this.default) / step) * step + this.default;
          }
          return this._safeAdd(this._safeMult(Math.round((value - this.default) / step), step), this.default);
        }
        if (this.min !== undefined) {
          if (this._isInteger) {
            return Math.round((value - this.min) / step) * step + this.min;
          }
          return this._safeAdd(this._safeMult(Math.round((value - this.min) / step), step), this.min);
        }
        if (this.max !== undefined) {
          if (this._isInteger) {
            return Math.round(-(this.max - value) / step) * step + this.max;
          }
          return this._safeAdd(this._safeMult(-Math.round((this.max - value) / step), step), this.max);
        }
        if (this._isInteger) {
          return Math.round(value / step) * step
        }
        return this._safeAdd(this._safeMult(Math.round(value / step), step), 0);
      }

      /**
       * emulating handwritten multiplication
       * @param  {[number]} a [factor]
       * @param  {[number]} b [factor]
       * @return {[type]}   [product]
       */
      _safeMult(a, b) {
        a = '' + (a || 0);
        b = '' + (b || 0);

        const aDecimal = a.slice(a.indexOf('.')).length - 1;
        const bDecimal = b.slice(b.indexOf('.')).length - 1;

        const decimal = aDecimal + bDecimal;
        const sign = (a[0] === '-' ? b[0] !== '-' : b[0] === '-') ? '-' : '';

        a = a.replace(/\D/g, '');
        b = b.replace(/\D/g, '');

        let whole = 0;
        for (let i = 0; i < b.length; i++) {
          whole += Math.pow(10, b.length - 1 - i) * Number(a) * Number(b[i]);
        }
        whole = '' + whole;
        for (let i = whole.length; i < decimal; i++) {
          whole = '0' + whole;
        }
        return Number(sign + whole.slice(0, whole.length - decimal) + '.' + whole.slice(whole.length - decimal));
      }

      /**
       * emulating handwritten addition
       * @param  {[number]} a [summand]
       * @param  {[number]} b [summand]
       * @return {[type]}   [sum]
       */
      _safeAdd(a, b) {
        a = '' + (a || 0);
        b = '' + (b || 0);

        const aDecimal = a.slice(a.indexOf('.')).length - 1;
        const bDecimal = b.slice(b.indexOf('.')).length - 1;

        const decimal = Math.max(aDecimal, bDecimal);

        let whole = Math.round( Math.pow(10, decimal) * Number(a) +
                                Math.pow(10, decimal) * Number(b) );

        const sign = whole < 0 ? '-' : '';
        whole = '' + Math.abs(whole);
        for (let i = whole.length; i < decimal; i++) {
          whole = '0' + whole;
        }

        return Number(sign + whole.slice(0, whole.length - decimal) + '.' + whole.slice(whole.length - decimal));
      }

      _stepChanged(step) {
        if (!step) {
          this.step = 1;
          return;
        } else if (step !== Math.abs(step)) {
          this.step = Math.abs(step);
          return;
        }
        this._updateValue();
      }

      _computeIsInteger(step) {
        return step === Math.round(step);
      }
    }
  }

  window.RangeMixin = RangeMixin;
</script>
