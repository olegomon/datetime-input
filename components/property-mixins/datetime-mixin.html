<script>
  /**
   * Mixin that provides datetime-properties
   *
   * @mixinFunction
   * @polymer
   *
   * @param {Object} superClass class to extend
   * @return {Object} extended class
   */
  const DatetimeMixin = (superClass) => { // eslint-disable-line no-unused-vars no-undef

    return class extends superClass {

      static get properties() {
        return {
          /**
           * the selected local date and time (format: iso8601)
           */
          datetime: {
            type: String,
            notify: true
          },
          /**
           * the selected local date (format: iso8601)
           */
          date: {
            type: String,
            notify: true
          },

          /**
           * the selected local time (format: iso8601)
           */
          time: {
            type: String,
            notify: true
          },

          /**
           * The year of the selected local date
           */
          year: {
            type: Number,
            notify: true
          },

          /**
           * The month of the selected local date (starts with 1)
           */
          month: {
            type: Number,
            notify: true
          },

          /**
           * The day of the selected local date
           */
          day: {
            type: Number,
            notify: true
          },

          /**
           * The hours of the selected local time
           */
          hours: {
            type: Number,
            notify: true,
            observer: '_hoursChanged'
          },

          /**
           * The minutes of the selected local time
           */
          minutes: {
            type: Number,
            notify: true
          },

          /**
           * The seconds of the selected local time
           */
          seconds: {
            type: Number,
            notify: true
          },

          /**
           * The milliseconds of the selected local time
           */
          milliseconds: {
            type: Number,
            notify: true
          },

          /**
           * The value of the selected local date
           */
          value: {
            type: Number,
            notify: true,
            observer: '_valueChanged'
          },

          /**
           * The default value of the input
           */
          default: {
            type: String,
            notify: true
          },

          /**
           * The minimal local date,
           * could be a number, a date-object or an iso-string
           */
          min: {
            type: String,
            notify: true,
            observer: '_minChanged'
          },

          /**
           * The maximal local date,
           * could be a number, a date-object or an iso-string
           */
          max: {
            type: String,
            notify: true,
            observer: '_maxChanged'
          },

          /**
           * when true, 12-hour time format, else 24-hour
           * @type {boolean}
           */
          hour12: {
            type: Boolean,
            value: false
          },

          /**
           * true, when A.M. (when `hours` < 12)
           * @type {boolean}
           */
          isAm: {
            type: Boolean,
            observer: '_isAmChanged'
          },

          /**
           * hours in 12-hour-format
           * @type {number}
           */
          hours12: {
            type: Number,
            notify: true,
            observer: '_hours12Changed'
          },

          /**
           * Clamp datetime to a property
           * possible values:'month', 'day', 'hours', 'minutes', 'seconds', 'milliseconds'
           */
          clamp: {
            type: String
          },

          /**
           * The current locale
           */
          locale: {
            type: String,
            value: window.navigator.language,
            observer: '_localeChanged'
          },

          /**
           * The local timezone offset in 'Â±hh:mm' format
           */
          timezone: {
            type: String,
            notify: true,
            observer: '_timezoneChanged'
          },

          /**
           * The offset minutes of the set timezone
           */
          _timezoneOffset: {
            type: Number,
            observer: '_timezoneOffsetChanged'
          },

          _timeZoneHours: {
            type: Number
          },

          _timeZoneMinutes: {
            type: Number
          },

          /**
           * The offset minutes of the current datetime
           */
          _recentLocalTimezoneOffset: {
            type: Number
          },

          /**
           * locale representation of 'AM'
           */
          _am: {
            type: String
          },

          /**
           * locale representation of 'PM'
           */
          _pm: {
            type: String
          },

          /**
           * Separator for local date values (date-string is still in ISO-Format)
           * @type {string}
           */
          _localDateSeparator: {
            type: String,
            value: '-'
          },

          /**
           * Separator for local time values (time-string is still in ISO-Format)
           * @type {string}
           */
          _localTimeSeparator: {
            type: String,
            value: ':'
          },

          /**
           * Separator for local decimal values
           * @type {string}
           */
          _localDecimalSeparator: {
            type: String,
            value: '.'
          },

          /**
           * order of date-parts
           */
          _orderDate: {
            type: Object,
            value: function() {
              return {
                year: 1,
                separatorYearMonth: 2,
                month: 3,
                separatorMonthDay: 4,
                day: 5
              };
            }
          },

          /**
           * exclusive max day of month
           * @type {number}
           */
          _maxDayOfMonth: {
            type: Number,
            computed: '_computeMaxDayOfMonth(year, month)'
          },

          /**
           * Regular Expression for datetime-string
           */
          _regexpDatetime: {
            type: RegExp,
            value: /^(-?\d+-\d\d-\d\d)(?:T?(?:(\d\d:\d\d(?::\d\d(?:\.\d\d\d)?)?)([+-]\d\d:\d\d|Z)?)?)$/
          },

          /**
           * Regular Expression for datetime-string
           */
          _regexpTimezone: {
            type: RegExp,
            value: /^(?:([+-]\d\d):(\d\d)|Z)$/
          },

          /**
           * lock to date and ignore time
           */
          _dateLocked: {
            type: Boolean,
            computed: '_ifClamped(clamp, "hours")'
          }
        }
      }

      static get observers() {
        return [
          '_computeDatetime(year, month, day, hours, minutes, seconds, milliseconds)',
          '_datetimeChanged(datetime)',
          '_dateTimeChanged(date, time)',
          '_timeZoneHoursMinutesChanged(_timeZoneHours, _timeZoneMinutes)',
          '_defaultChanged(default)'
        ]
      }

      _defaultChanged(def) {
        if (!def) {
          return;
        }
        const d = this._fromDatetime(def);
        if (isNaN(d)) {
          return;
        }
        if (this.value === undefined) {
          this._setDate(d);
        }
      }

      /**
       *  Sets value to the actual date
       **/
      now() {
        this._setDate(new Date());
      }

      _computeDatetime(year, month, day, hours, minutes, seconds, milliseconds) {
        if (this.__updatingTimezoneOffset) {
          return;
        }
        let d;
        if (year === undefined && month === undefined && day === undefined && hours === undefined && minutes === undefined && seconds === undefined && milliseconds === undefined) {
          if (this.default !== undefined) {
            this._setDate(new Date(this.default));
          } else {
            this._resetDate();
          }
          return;
        } else if (year === undefined || month === undefined || day === undefined || hours === undefined || minutes === undefined || seconds === undefined || milliseconds === undefined) {
          if (this.timezone === undefined) {
            this.__updatingTimezoneOffset = true;
            this.setProperties(this._computeTimezone(new Date().getTimezoneOffset()));
            this.__updatingTimezoneOffset = false;
          }
          d = new Date(this.value !== undefined ? this.value : this.datetime || ((this.date || this._toDate(new Date())) + 'T' + (this.time || this._toTime(new Date()).slice(0, 5)) + this.timezone));
          if (isNaN(d)) {
            d = new Date();
          }
          if (year !== undefined) {
            d.setFullYear(year);
          }
          if (month !== undefined) {
            d.setMonth(month - 1);
          }
          if (day !== undefined) {
            d.setDate(day);
          }
          if (hours !== undefined) {
            d.setHours(hours);
          }
          if (minutes !== undefined) {
            d.setMinutes(minutes);
          }
          if (seconds !== undefined) {
            d.setSeconds(seconds);
          }
          if (milliseconds !== undefined) {
            d.setMilliseconds(milliseconds);
          }
        } else {
          d = new Date(year, month - 1, day, hours, minutes, seconds, milliseconds);
          d.setFullYear(year);
        }
        const localTimezoneOffset = d.getTimezoneOffset();
        if (this._timezoneOffset === undefined) {
          this.__updatingTimezoneOffset = true;
          this.setProperties(this._computeTimezoneOffset(this.timezone));
          this.__updatingTimezoneOffset = false;
        }
        if (this._recentLocalTimezoneOffset === undefined) {
          this._recentLocalTimezoneOffset = localTimezoneOffset;
        } else if (this._recentLocalTimezoneOffset !== localTimezoneOffset) {
          this.__updatingTimezoneOffset = true;
          // fixing offset when an inner shift occures (e.g. summer- or wintertime)
          this.setProperties(this._computeTimezone(this._timezoneOffset - this._recentLocalTimezoneOffset + localTimezoneOffset));
          this._recentLocalTimezoneOffset = localTimezoneOffset;
          this.__updatingTimezoneOffset = false;
        }
        d.setMinutes(d.getMinutes() + this._timezoneOffset - localTimezoneOffset);
        this._setDate(d);
      }

      _dateTimeChanged(date, time) {
        if (this.__updatingTimezoneOffset) {
          return;
        }
        if ((date === undefined && time === undefined) || this.timezone === undefined) {
          if (this.default !== undefined) {
            this._setDate(new Date(this.default));
          } else {
            this._resetDate();
          }
          return;
        }
        this.datetime = (date || '1970-01-01') + 'T' + (time || (this.timezone ? this.timezone.slice(1) : '00:00')) + (this.timezone || 'Z');
      }

      _datetimeChanged(datetime) {
        if (datetime === undefined) {
          if (this.default !== undefined) {
            this._setDate(new Date(this.default));
          } else {
            this._resetDate();
          }
          return;
        }

        if (typeof datetime === 'object') {
          // 'date' is a Date Object
          this._recentLocalTimezoneOffset = datetime.getTimezoneOffset();
          this._setDate(datetime);
          return;
        }

        let d;
        const match = this._regexpDatetime.exec(datetime);
        if (match === null) {
          return;
        }
        if (match[3] === undefined) {
          d = new Date(match[1] + 'T' + match[2] + 'Z');
          if (this._timezoneOffset === undefined) {
            this.__updatingTimezoneOffset = true;
            if (this.timezone) {
              this.setProperties(this._computeTimezoneOffset(this.timezone));
            } else {
              this.setProperties(this._computeTimezone(d.getTimezoneOffset()));
            }
            this.__updatingTimezoneOffset = false;
          }
          d.setMinutes(d.getMinutes() + this._timezoneOffset);
        } else {
          d = new Date(match[0]);
          if (match[3] !== this.timezone) {
            this.__updatingTimezoneOffset = true;
            this.setProperties(this._computeTimezoneOffset(match[3]));
            this.__updatingTimezoneOffset = false;
          }
        }

        this._recentLocalTimezoneOffset = d.getTimezoneOffset();
        this._setDate(d);
      }

      _valueChanged(value) {
        if (isNaN(value)) {
          if (this.default !== undefined) {
            this._setDate(new Date(this.default));
          } else {
            this._resetDate();
          }
          return;
        }

        this._setDate(typeof value === 'object' ? value : new Date(+value));
      }

      /**
       * [_setDate sets date to all necessary properties]
       * @param {[Date]} d [the date to set]
       */
      _setDate(d) {
        if (!isNaN(d)) {
          d = this._checkThreshold(d);

          const localTimezoneOffset = d.getTimezoneOffset();

          if (this._timezoneOffset === undefined || this._recentLocalTimezoneOffset !== localTimezoneOffset) {
            // noticing the possible timezone shift by the threshold check
            this.__updatingTimezoneOffset = true;
            this.setProperties(this._computeTimezone(localTimezoneOffset));
            this.__updatingTimezoneOffset = false;
          }
          this._recentLocalTimezoneOffset = localTimezoneOffset;

          const value = +d;

          if (this.value !== value) {
            this.value = value;
            return;
          }

          d.setMinutes(d.getMinutes() - this._timezoneOffset + this._recentLocalTimezoneOffset);

          d = this._clamp(d, this.clamp);

          const year = d.getFullYear(),
            month = d.getMonth() + 1,
            day = d.getDate(),
            hours = d.getHours(),
            minutes = d.getMinutes(),
            seconds = d.getSeconds(),
            milliseconds = d.getMilliseconds();

          if (year !== this.year || month !== this.month || day !== this.day || hours !== this.hours || minutes !== this.minutes  || seconds !== this.seconds || milliseconds !== this.milliseconds) {
            this.setProperties({
              year: year,
              month: month,
              day: day,
              hours: hours,
              minutes: minutes,
              seconds: seconds,
              milliseconds: milliseconds
            });
            return;
          }

          const date = this._toDate(d),
            time = this._dateLocked ? '00:00' : this._toTime(d),
            datetime = date + 'T' + time + this.timezone;

          if (this.datetime !== datetime || this.time !== time || this.date !== date) {
            this.setProperties({
              datetime: datetime,
              date: date,
              time: time
            });
          }
        } else if (!isNaN(d = new Date(this.default))) {
          this._setDate(d);
        } else if (!isNaN(this.value)) {
          this._valueChanged(this.value);
        }
      }

      _resetDate(e) {
        if (e && e.stopPropagation) {
          e.stopPropagation();
        }
        this.setProperties({
          value: undefined,
          datetime: undefined,
          date: undefined,
          time: undefined,
          year: undefined,
          month: undefined,
          day: undefined,
          hours: undefined,
          minutes: undefined,
          seconds: undefined,
          milliseconds: undefined,
          timezone: undefined,
          _timezoneOffset: undefined,
          _timeZoneHours: undefined,
          _timeZoneMinutes: undefined
        });
      }

      _clamp(d, clamp) {
        switch (clamp) {
          case 'year':
          case 'month':
            d.setMonth(0); // falls through
          case 'day':
            d.setDate(1); // falls through
          case 'hours':
            d.setHours(0); // falls through
          case 'minutes':
            d.setMinutes(0); // falls through
          case 'seconds':
            d.setSeconds(0); // falls through
          case 'milliseconds':
            d.setMilliseconds(0);
        }
        return d;
      }

      _pad(n, padLength) {
        const sign = n < 0 ? '-' : '';
        let str = '' + Math.abs(n);
        while (str.length < padLength)
          str = '0' + str;
        return sign + str;
      }

      _fromDatetime(datetime) {
        if (datetime === undefined) {
          return;
        }
        if (typeof datetime === 'object' && datetime.getDate) {
          // 'datetime' is a Date Object
          return datetime;
        }
        if (typeof datetime === 'number' && !isNaN(datetime)) {
          // 'datetime' is a number
          return new Date(datetime);
        }
        let d;
        const match = this._regexpDatetime.exec(datetime);
        if (match) {
          if (match[3] !== undefined) {
            d = new Date(match[0]);
          } else {
            d = new Date(match[1] + 'T' + (match[2] || '00:00') + 'Z');
            if (this._timezoneOffset === undefined) {
              this.__updatingTimezoneOffset = true;
              if (this.timezone) {
                this.setProperties(this._computeTimezoneOffset(this.timezone));
              } else {
                this.setProperties(this._computeTimezone(d.getTimezoneOffset()));
              }
              this._recentLocalTimezoneOffset = this._timezoneOffset;
              this.__updatingTimezoneOffset = false;
            }
            d.setMinutes(d.getMinutes() + this._timezoneOffset);
          }
        }
        return d;
      }

      _minChanged(min) {
        const d = this._fromDatetime(min);
        if (isNaN(d)) {
          return;
        }
        const max = this.max && this._fromDatetime(this.max);
        if (d > max) {
          this.setProperties({
            min: this.max,
            max: min
          });
          return;
        }
        this._min = d;
        if (!isNaN(this.value)) {
          this.value = +this._checkThreshold(new Date(this.value));
        }
      }

      _maxChanged(max) {
        const d = this._fromDatetime(max);
        if (isNaN(d)) {
          return;
        }
        const min = this.min && this._fromDatetime(this.min);
        if (min > d) {
          this.setProperties({
            min: max,
            max: this.min
          });
          return;
        }
        this._max = d;
        if (!isNaN(this.value)) {
          this.value = +this._checkThreshold(new Date(this.value));
        }
      }

      _checkThreshold(d) {
        if (this._min > d) {
          return new Date(this._min);
        }
        if (this._max < d) {
          return new Date(this._max);
        }
        return d;
      }

      _toDate(d) {
        if (typeof d === 'number') {
          d = new Date(d);
        }
        const year = d.getFullYear();
        return this._pad(year, year < 0 ? 6 : 4) + '-' + this._pad(d.getMonth() + 1, 2) + '-' + this._pad(d.getDate(), 2);
      }

      _toTime(d) {
        if (typeof d === 'number') {
          d = new Date(d);
        }
        return this._pad(d.getHours(), 2) + ':' + this._pad(d.getMinutes(), 2) + ':' + this._pad(d.getSeconds(), 2) + '.' + this._pad(d.getMilliseconds(), 3);
      }

      _hoursChanged(hours) {
        if (hours === undefined) {
          this.setProperties({
            isAm: undefined,
            hours12: undefined
          })
        }
        this.isAm = hours < 12;
        this.hours12 = (hours === 0) ? 12 : (hours > 12 ? hours - 12 : hours);
      }

      _hours12Changed(hours12) {
        if (hours12 === undefined) {
          this.hours = undefined;
        } else {
          this.hours = (hours12 === 12) ? (this.isAm ? 0 : 12) : (this.isAm ? hours12 : hours12 + 12);
        }
      }

      _isAmChanged(isAm) {
        if (isAm === undefined) return;

        if (this.hours >= 12 && isAm === true) {
          this.hours -= 12;
        } else if (this.hours <= 12 && isAm === false) {
          this.hours += 12;
        }
      }

      /**
       * clamp to date component
       * @param  {string} clamp 'clamp'-property
       * @param  {string} comp the property to compare to
       * @return {boolean}     true when should be hidden
       */
      _ifClamped(clamp, comp) {
        const features = ['month', 'day', 'hours', 'minutes', 'seconds', 'milliseconds'];
        const pos = features.indexOf(clamp);
        const index = features.indexOf(comp);
        return pos !== -1 && index !== -1 && pos <= index;
      }

      _localeChanged(locale) {
        if (!locale) {
          this.locale = window.navigator.language;
          return;
        }
        // test locale (currently just for Latin letters and Western Arabic/European numerals)
        locale += '-u-nu-latn-ca-iso8601';

        let date = new Date(1970, 10, 15, 6, 24, 25);

        // check date
        const dateString = date.toLocaleDateString(locale, {
          year: 'numeric',
          month: 'numeric',
          day: 'numeric'
        });

        // date separator
        const dateSeparator = dateString.split(/\d+/g).filter(Boolean).pop();

        // order of the date parts
        let parts = dateString.match(/\d+/g);
        parts.splice(1, 0, '');
        parts.splice(3, 0, '');

        let order = {};
        order.year = parts.indexOf('1970') + 1;
        order.month = parts.indexOf('11') + 1;
        order.day = parts.indexOf('15') + 1;
        order.separatorYearMonth = order.year > order.month ? order.year - 1 : order.month - 1;
        order.separatorMonthDay = order.month > order.day ? order.month - 1 : order.day - 1;

        // check time
        let timeString = date.toLocaleTimeString(locale, {
          hour: 'numeric',
          minute: 'numeric',
          second: 'numeric',
          hour12: false
        });

        // time separator
        const timeSeparator = timeString.split(/\d/g).filter(s => {
          return s !== '';
        }).pop();

        // am-string
        timeString = date.toLocaleTimeString(locale, {
          hour: 'numeric',
          minute: 'numeric',
          second: 'numeric',
          hour12: true
        });
        const am = timeString.split(/\d/g).filter(s => {
          return /[^\s:|/,;.]{1}/.test(s);
        }).pop();

        // pm-string
        date = new Date(1970, 10, 15, 18, 24, 25);
        timeString = date.toLocaleTimeString(locale, {
          hour: 'numeric',
          minute: 'numeric',
          second: 'numeric',
          hour12: true
        });
        const pm = timeString.split(/\d/g).filter(s => {
          return /[^\s:|/,;.]{1}/.test(s);
        }).pop();

        // decimal separator
        let decimalSeparator = new Intl.NumberFormat(locale).format(1.2).split(/\d/g).filter(s => {
          return s !== '';
        }).pop();

        this.setProperties({
          _orderDate: order,
          _localDateSeparator: dateSeparator,
          _localTimeSeparator: timeSeparator,
          _localDecimalSeparator: decimalSeparator,
          _am: am,
          _pm: pm
        });
      }

      _timezoneChanged(timezone, oldValue) {
        if (timezone === undefined) {
          this._resetDate();
          return;
        } else if (!(this._regexpTimezone.exec(timezone))) {
          if (this._regexpTimezone.exec(oldValue)) {
            this.setProperties(this._computeTimezoneOffset(oldValue));
            return;
          }
          this.setProperties(this._computeTimezone((this.value === undefined ? new Date() : new Date(this.value)).getTimezoneOffset()));
          return;
        }
        if (this.__updatingTimezoneOffset) {
          return;
        }

        const toSet = this._computeTimezoneOffset(timezone);
        if (toSet._timezoneOffset !== this._timezoneOffset) {
          this.__updatingTimezoneOffset = true;
          this.setProperties(this._computeTimezoneOffset(timezone));
          this.__updatingTimezoneOffset = false;
        }
      }

      _timezoneOffsetChanged(offsetMinutes) {
        if (offsetMinutes === undefined) {
          return;
        }
        if (this.__updatingTimezoneOffset) {
          return;
        }
        this.setProperties(this._computeTimezone(offsetMinutes));
      }

      _timeZoneHoursMinutesChanged(hours, minutes) {
        if (hours === undefined || minutes === undefined) {
          return;
        }
        const offsetMinutes = -Math.sign(hours)*(Math.abs(hours) * 60 + minutes),
          timezone = (hours >= 0 ? '+' : '') + this._pad(hours, 2) + ':' + this._pad(minutes, 2);
        if (offsetMinutes !== this._timezoneOffset) {
          this.__updatingTimezoneOffset = true;
          this.setProperties({
            _timezoneOffset: offsetMinutes,
            timezone: timezone
          });
          this.__updatingTimezoneOffset = false;
        } else if (this.timezone !== timezone) {
          this.timezone = timezone;
        }
        if (this.date && this.time) {
          this.datetime = this.date + 'T' + this.time + this.timezone;
        }
      }

      _computeTimezone(offsetMinutes) { // offset in minutes
        if (offsetMinutes === undefined) {
          return {};
        } else if (offsetMinutes === 0) {
          return {
            _timezoneOffset: 0,
            _timeZoneHours: 0,
            _timeZoneMinutes: 0,
            timezone: '+00:00'
          };
        }
        const hours = -Math.sign(offsetMinutes)*Math.floor(Math.abs(offsetMinutes) / 60),
        minutes = Math.abs(offsetMinutes) % 60;
        return {
          _timezoneOffset: offsetMinutes,
          _timeZoneHours: hours,
          _timeZoneMinutes: minutes,
          timezone: (hours >= 0 ? '+' : '') + this._pad(hours, 2) + ':' + this._pad(minutes, 2)
        }
      }

      _computeTimezoneOffset(timezone) {
        if (timezone === 'Z') {
          return {
            _timezoneOffset: 0,
            _timeZoneHours: 0,
            _timeZoneMinutes: 0,
            timezone: '+00:00'
          };
        }
        const match = this._regexpTimezone.exec(timezone);
        if (match) {
          const hours = +match[1],
            minutes = +match[2];
          return {
            _timezoneOffset: -Math.sign(hours)*(Math.abs(hours) * 60 + minutes),
            _timeZoneHours: hours,
            _timeZoneMinutes: minutes,
            timezone: timezone
          };
        }
      }

      _computeMaxDayOfMonth(year, month) {
        const d = new Date(year, month, 0);
        d.setFullYear(year);

        if (!isNaN(+d)) {
          return d.getDate();
        }
        return 31;
      }
    }
  }

  window.DatetimeMixin = DatetimeMixin;
</script>
