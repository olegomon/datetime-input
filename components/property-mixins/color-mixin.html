<script>
  /**
   * Mixin that provides web-color-properties. Its value converts automatically beetween different formats (hex, rgb and hsl) and provides an alpha-value.
   *
   * @mixinFunction
   * @polymer
   */
  const ColorMixin = (superClass) => { // eslint-disable-line no-unused-vars no-undef

    return class extends superClass {

      constructor() {
        super();
        this._validFormats = ['rgb', 'hex', 'hsl'];
      }

      static get properties() {
        return {
          /**
           * Hex-color
           */
          hex: {
            type: String,
            notify: true,
            observer: '_hexChanged'
          },
          /**
           * Red
           */
          r: {
            type: Number,
            notify: true
          },
          /**
           * Green
           */
          g: {
            type: Number,
            notify: true
          },
          /**
           * Blue
           */
          b: {
            type: Number,
            notify: true
          },
          /**
           * Hue
           */
          h: {
            type: Number,
            notify: true
          },
          /**
           * Saturation (hsl)
           */
          s: {
            type: Number,
            notify: true
          },
          /**
           * Lightness
           */
          l: {
            type: Number,
            notify: true
          },
          /**
           * Alpha
           */
          alpha: {
            type: Number,
            notify: true,
            value: 1,
            observer: '_alphaChanged'
          },

          /**
           * if true, value has alpha
           */
          alphaMode: {
            type: Boolean,
            notify: true,
            observer: '_alphaModeChanged'
          },
          /**
           * Precision of hsl-values, if the format is 'hsl' (for saturation and lightness it is applied according to their percentage value)
           */
          hslPrecision: {
            type: Number,
            value: 2
          },
          /**
           * format of the value (possible values: 'rgb', 'hex', 'hsl')
           */
          format: {
            type: String,
            notify: true,
            value: 'hex',
            observer: '_formatChanged'
          },
          /**
           * hex-color
           */
          value: {
            type: String,
            notify: true,
            reflectToAttribute: true,
            observer: '_valueChanged'
          },

          _validateHex: {
            type: RegExp,
            readOnly: true,
            value: /^\s*(?:(#(?:[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3}))|rgba\(\s*(#(?:[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3}))\s*,\s*(-?\d*(?:\.(?:\d*)?)?)\s*\))\s*$/
          },

          _validateRgb: {
            type: RegExp,
            readOnly: true,
            value: /^\s*rgb(a)?\(\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*(-?\d+)(?:\s*,\s*(-?\d*(?:\.(?:\d*)?)?))?\s*\)\s*$/
          },

          _validateHsl: {
            type: RegExp,
            readOnly: true,
            value: /^\s*hsl(a)?\(\s*(-?\d+(?:\.\d*)?)\s*,\s*(-?\d*(?:\.(?:\d*)?)?%?)\s*,\s*(-?\d*(?:\.(?:\d*)?)?%?)(?:\s*,\s*(-?\d*(?:\.(?:\d*)?)?))?\s*\)\s*$/
          },

          _validatePercent: {
            type: RegExp,
            readOnly: true,
            value: /(-?\d*(?:\.(?:\d*)?)?)%/
          }

        }
      }

      static get observers() {
        return [
          '_rgbChanged(r, g, b)',
          '_hslChanged(h, s, l)'
        ];
      }

      connectedCallback() {
        super.connectedCallback();
        // create a random color, if value or hex is not set
        if (this.value === undefined && this.hex === undefined) {
          if (this.h !== undefined || this.s !== undefined || this.l !== undefined) {
            const hsl = this.randomHsl();
            this.setProperties({
              h: this.h || hsl.h,
              s: this.s || hsl.s,
              l: this.l || hsl.l
            });
          } else {
            const rgb = this.randomRgb();
            this.setProperties({
              r: this.r || rgb.r,
              g: this.g || rgb.g,
              b: this.b || rgb.b
            });
          }
        }
      }

      _alphaModeChanged(alphaMode) {
        if (alphaMode !== true) {
          this.alpha = 1;
        }
      }

      _formatChanged(format, oldFormat) {
        if (format === undefined) {
          return;
        }
        if (this._validFormats.indexOf(format) === -1) {
          if (oldFormat && this._validFormats.indexOf(oldFormat) !== -1) {
            this.format = oldFormat;
            return;
          }
          this.format = 'hex';
          return;
        }
        this._debouncedSetValue();
      }

      _valueChanged(value, oldValue) {
        if (value === undefined) return;

        let toSet = {},
          match;
        // input-format detection
        switch (this.format) {
          case 'hsl':
            if (match = value.match(this._validateHsl)) {
              if (match[1] === undefined) { // no alpha
                toSet.alpha = 1;
                toSet.alphaMode = false;
              } else { // with alpha
                toSet.alpha = this._normalizedClamp(+match[5]);
                toSet.alphaMode = true;
              }
              toSet.h = this._mathMod(+match[2], 360);
              let matchPercent;
              if (matchPercent = match[3].match(this._validatePercent)) { // s in percentage value
                toSet.s = this._normalizedClamp(+matchPercent[1] * 0.01);
              } else {
                toSet.s = this._normalizedClamp(+match[3]);
              }
              if (matchPercent = match[4].match(this._validatePercent)) { // l in percentage value
                toSet.l = this._normalizedClamp(+matchPercent[1] * 0.01);
              } else {
                toSet.l = this._normalizedClamp(+match[4]);
              }
            }
            break;
          case 'hex': // falls through
            if (match = value.match(this._validateHex)) {
              if (match[1] !== undefined) { // no alpha
                toSet.hex = match[1];
                toSet.alpha = 1;
                toSet.alphaMode = false;
              } else { // with alpha
                toSet.hex = match[2];
                toSet.alpha = this._normalizedClamp(+match[3]);
                toSet.alphaMode = true;
              }
              break;
            }
          case 'rgb': // falls through
          default:
            if (match = value.match(this._validateRgb)) {
              if (match[1] === undefined) { // no alpha
                toSet.alpha = 1;
                toSet.alphaMode = false;
              } else { // with alpha
                toSet.alpha = this._normalizedClamp(+match[5]);
                toSet.alphaMode = true;
              }
              toSet.r = this._mathMod(+match[2], 256);
              toSet.g = this._mathMod(+match[3], 256);
              toSet.b = this._mathMod(+match[4], 256);
            }
        }
        if (!match && oldValue !== undefined) {
          this._valueChanged(oldValue);
        }
        this.setProperties(toSet);
      }

      _debouncedSetValue() {
        if (this._activeSetValueJob) {
          window.cancelAnimationFrame(this._activeSetValueJob);
        }
        this._activeSetValueJob = window.requestAnimationFrame(this._setValue.bind(this))
      }

      _setValue() {
        switch (this.format) {
          case 'hsl':
            if (this.h !== undefined && this.s !== undefined && this.l !== undefined) {
              if (this.alphaMode === true) {
                this.value = `hsla(${+this.h.toFixed(this.hslPrecision || 0)},${+(this.s*100).toFixed(this.hslPrecision || 0)}%,${+(this.l*100).toFixed(this.hslPrecision || 0)}%,${this.alpha === undefined ? 0 : this.alpha})`;
              } else {
                this.value = `hsl(${+this.h.toFixed(this.hslPrecision || 0)},${+(this.s*100).toFixed(this.hslPrecision || 0)}%,${+(this.l*100).toFixed(this.hslPrecision || 0)}%)`;
              }
            }
            break;
          case 'rgb':
            if (this.r !== undefined && this.g !== undefined && this.b !== undefined) {
              if (this.alphaMode === true) {
                this.value = `rgba(${Math.round(this.r)},${Math.round(this.g)},${Math.round(this.b)},${this.alpha === undefined ? 0 : this.alpha})`;
              } else {
                this.value = `rgb(${Math.round(this.r)},${Math.round(this.g)},${Math.round(this.b)})`;
              }
            }
            break;
          case 'hex':
          default:
            if (this.alpha === 1 && this.hex !== undefined) {
              this.value = this.hex;
            } else if (this.r !== undefined && this.g !== undefined && this.b !== undefined) {
              this.value = `rgba(${Math.round(this.r)},${Math.round(this.g)},${Math.round(this.b)},${this.alpha === undefined ? 0 : this.alpha})`;
            }
        }
      }

      _alphaChanged(alpha, oldAlpha) {
        if (isNaN(alpha)) {
          this.alpha = 1;
          return;
        }
        if (alpha > 1) {
          if (oldAlpha !== undefined) {
            this.alpha = oldAlpha;
            return;
          }
          this.alpha = 1;
          return;
        }
        if (alpha < 0) {
          if (oldAlpha !== undefined) {
            this.alpha = oldAlpha;
            return;
          }
          this.alpha = 0;
          return;
        }
        if (alpha !== 1) {
          this.alphaMode = true;
        }
        this._debouncedSetValue();
      }

      _hexChanged(hex) {
        if (hex === undefined) {
          return;
        }
        let toSet = {};
        const rgb = this.hexToRgb(hex);
        if (rgb.r !== Math.round(this.r)) {
          toSet.r = rgb.r;
        }
        if (rgb.g !== Math.round(this.g)) {
          toSet.g = rgb.g;
        }
        if (rgb.b !== Math.round(this.b)) {
          toSet.b = rgb.b;
        }
        this.setProperties(toSet);
        this._debouncedSetValue();
      }

      _rgbChanged(r, g, b) {
        if (r === undefined || g === undefined || b === undefined) {
          return;
        }
        r = this._mathMod(r, 256);
        g = this._mathMod(g, 256);
        b = this._mathMod(b, 256);
        let toSet = {};
        // avoid multiple conversion to hsl by checking if the current hsl-values convert to the same rgb-values
        const rgbFromCurrentHsl = this.hslToRgb(this.h, this.s, this.l) || {};
        if (r !== rgbFromCurrentHsl.r || g !== rgbFromCurrentHsl.g || b !== rgbFromCurrentHsl.b) {
          toSet = this.rgbToHsl(r, g, b);
        }
        const hex = this.rgbToHex(r, g, b);
        if (hex !== this.hex) {
          toSet.hex = hex;
        }
        this.setProperties(toSet);
        this._debouncedSetValue();
      }

      _hslChanged(h, s, l) {
        if (h === undefined || s === undefined || l === undefined) {
          return;
        }
        h = this._mathMod(h, 360);
        s = this._normalizedClamp(s);
        l = this._normalizedClamp(l);
        let toSet = {};
        const rgb = this.hslToRgb(h, s, l);
        if (rgb.r !== this.r) {
          toSet.r = rgb.r;
        }
        if (rgb.g !== this.g) {
          toSet.g = rgb.g;
        }
        if (rgb.b !== this.b) {
          toSet.b = rgb.b;
        }
        this.setProperties(toSet);
        this._debouncedSetValue();
      }

      /**
       * generate random color
       */
      random() {
        this.setProperties(this.randomRgb());
      }

      /**
       * generate random rgb-color
       * @return {object} rgb-value object
       */
      randomRgb() {
        return {
          r: Math.round(255 * Math.random()),
          g: Math.round(255 * Math.random()),
          b: Math.round(255 * Math.random())
        };
      }

      /**
       * generate random hsl-color
       * @return {object} rgb-value object
       */
      randomHsl() {
        return {
          h: Math.round(359 * Math.random()),
          s: Math.random(),
          l: Math.random()
        };
      }

      hexToRgb(hex) {
        if (hex === undefined) {
          return;
        }
        hex = hex.replace(/[#\s]/g, '');
        if (hex.length === 3) {
          hex = hex.replace(/(.)(.)(.)/, "$1$1$2$2$3$3");
        }

        return {
          r: parseInt(hex.substr(0, 2), 16),
          g: parseInt(hex.substr(2, 2), 16),
          b: parseInt(hex.substr(4, 2), 16)
        };
      }

      rgbToHex(r, g, b) {
        if (r === undefined || g === undefined || b === undefined) {
          return;
        }
        return '#' + this._componentToHex(Math.round(r)) + this._componentToHex(Math.round(g)) + this._componentToHex(Math.round(b));
      }

      _componentToHex(component) {
        const _hex = component.toString(16);
        if (_hex.length === 1) {
          return `0${_hex}`;
        } else {
          return _hex.slice(0, 2);
        }
      }

      hslToRgb(h, s, l) { // not rounded yet
        if (h === undefined || s === undefined || l === undefined) {
          return;
        }
        const t2 = ((l <= 0.5) ? l * (s + 1) : l + s - (l * s)) * 255,
          t1 = l * 2 * 255 - t2;
        return {
          r: Math.round(this.hueToComponent(t1, t2, h + 120)),
          g: Math.round(this.hueToComponent(t1, t2, h)),
          b: Math.round(this.hueToComponent(t1, t2, h - 120))
        };
      }

      hueToComponent(t1, t2, h) {
        if (h < 0) h += 360;
        if (h >= 360) h -= 360;
        if (h < 60) return (((t2 - t1) * h) / 60 + t1);
        else if (h < 180) return t2;
        else if (h < 240) return (((t2 - t1) * (240 - h)) / 60 + t1);
        else return t1;
      }

      rgbToHsl(r, g, b) {
        if (r === undefined || g === undefined || b === undefined) {
          return;
        }
        const max = Math.max(r, g, b),
          min = Math.min(r, g, b);

        const l = (max + min) / (2 * 255);
        const _c = max - min; // not-normalized chroma (for precision)

        if (_c === 0) {
          return [0, 0, l];
        }

        const s = _c / (255 - Math.abs(max + min - 255));
        let h;
        switch (max) {
          case r:
            h = ((g - b) * 60) / _c;
            break;
          case g:
            h = (((b - r) * 60) / _c) + 120;
            break;
          case b:
            h = (((r - g) * 60) / _c) + 240;
            break;
        }
        return {
          h: h,
          s: s,
          l: l
        };
      }

      _mathMod(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
      }

      _normalizedClamp(n) {
        return n > 1 ? 1 : n < 0 ? 0 : n;
      }
    }
  }

  window.ColorMixin = ColorMixin;
</script>
